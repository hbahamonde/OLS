cat("\014")
rm(list=ls())
graphics.off()
# Cargar paquete para cargar bases que no son de R.
# install.packages("foreign")
library(foreign) # significa "foraneo"
dat <- read.dta("cow.dta") # cargar base en  R (hasta el momento solo la habiamos descargado).
# Estimar modelo lineal: relacion entre crecimiento economico y democracia, controlando por poblacion
modelo.1 = lm(rgdpch ~ democracy + pop, dat)
# resumen del modelo
summary(modelo.1)
# resumen del modelo
options(scipen = 1000000)
summary(modelo.1)
10631.611789 - (1.96 * 754.563026)
confint(modelo.1, level = 0.95) # 95% de confianza
10631.611789 + (1.96 * 754.563026)
dat
# Estimar modelo lineal: relacion entre crecimiento economico y democracia, controlando por poblacion
modelo.1 = lm(repression ~ rgdpch + democracy, dat)
summary(modelo.1)
# Estimar modelo lineal: relacion entre crecimiento economico y democracia, controlando por poblacion
modelo.1 = lm(repression ~ rgdpch + pop, dat)
summary(modelo.1)
# Estimar modelo lineal: relacion entre crecimiento economico y democracia, controlando por poblacion
modelo.1 = lm(repression ~ democracy + pop, dat)
summary(modelo.1)
# plotear modelo
# install.packages("coefplot")
library(coefplot)
coefplot(modelo.1) # plot de coeficientes
# mostrar el detalle de los intervalos de confianza
confint(modelo.1)
# Estimar modelo lineal: relacion entre represion y democracia, controlando por poblacion.
# (1) Pensar por que seria importante "controlar por poblacion"?
modelo.1 = lm(democracy ~ pop, dat)
summary(modelo.1)
colnames(dat)
# Estimar modelo lineal: relacion entre represion y democracia, controlando por poblacion.
# (1) Pensar por que seria importante "controlar por poblacion"?
modelo.1 = lm(democracy ~ pop + rgdpch + , dat)
summary(modelo.1)
# Estimar modelo lineal: relacion entre represion y democracia, controlando por poblacion.
# (1) Pensar por que seria importante "controlar por poblacion"?
modelo.1 = lm(democracy ~ pop + rgdpch + , dat)
# Estimar modelo lineal: relacion entre represion y democracia, controlando por poblacion.
# (1) Pensar por que seria importante "controlar por poblacion"?
modelo.1 = lm(democracy ~ pop + rgdpch, dat)
summary(modelo.1)
colnames(dat)
# Estimar modelo lineal: relacion entre represion y democracia, controlando por poblacion.
# (1) Pensar por que seria importante "controlar por poblacion"?
modelo.1 = lm(democracy ~ pop + repression, dat)
summary(modelo.1)
# Estimar modelo lineal: relacion entre represion y democracia, controlando por poblacion.
# (1) Pensar por que seria importante "controlar por poblacion"?
modelo.1 = lm(democracy ~ repression + pop, dat)
summary(modelo.1)
# mostrar el detalle de los intervalos de confianza
confint(modelo.1)
# Estimar modelo lineal: relacion entre democracia y represion, controlando por poblacion.
# (1) Pensar por que seria importante "controlar por poblacion"?
modelo.1 = lm(democracy ~ repression, dat)
# Estimar modelo lineal: relacion entre democracia y represion, controlando por poblacion.
# (1) Pensar por que seria importante "controlar por poblacion"?
modelo.1 = lm(democracy ~ repression, dat)
summary(modelo.1)
# Estimar modelo lineal: relacion entre democracia y represion, controlando por poblacion.
# (1) Pensar por que seria importante "controlar por poblacion"?
modelo.1 = lm(democracy ~ pop, dat)
summary(modelo.1)
coefplot(modelo.1) # plot de coeficientes
# Estimar modelo lineal: relacion entre democracia y represion, controlando por poblacion.
# (1) Pensar por que seria importante "controlar por poblacion"?
modelo.1 = lm(pop ~ democracy , dat)
summary(modelo.1)
coefplot(modelo.1) # plot de coeficientes
colnames(dat)
# Modelo
modelo.1 = lm(pop ~ democracy + rgdpch , dat)
summary(modelo.1)
coefplot(modelo.1) # plot de coeficientes
colnames(dat)
# Modelo
modelo.1 = lm(pop ~ democracy + repression , dat)
summary(modelo.1)
coefplot(modelo.1) # plot de coeficientes
confint(modelo.1)
# Modelo
modelo.1 = lm(pop ~ democracy + repression , dat)
# resumen del modelo
options(scipen = 1000000) # apagar notacion cientifica.
summary(modelo.1)
# (1) Que podemos deducir de nuestro modelo? (Interpreta la tabla)
#################################################################
# Apliquemos lo que sabemos respecto a Intervalos de Confianza
#################################################################
# plotear modelo
# install.packages("coefplot")
library(coefplot)
coefplot(modelo.1) # plot de coeficientes
library(texreg)
screenreg(modelo.1)
library(effects)
plot(allEffects(modelo.1))
coefplot(modelo.1) # plot de coeficientes
coefplot(modelo.1) # plot de coeficientes
# Plotear modelo
# install.packages("coefplot")
library(coefplot)
coefplot(modelo.1) # plot de coeficientes
modelo.1 = lm(pop ~ democracy + repression , dat)
coefplot(modelo.1) # plot de coeficientes
coefplot(modelo.1) # plot de coeficientes
modelo.1
options(scipen = 1000000) # apagar notacion cientifica.
summary(modelo.1)
coefplot(modelo.1) # plot de coeficientes
confint(modelo.1)
lm(pop ~ democracy + repression , dat)
# Modelo
modelo.1 = lm(pop ~ democracy + repression, dat)
summary(modelo.1)
coefplot(modelo.1) # plot de coeficientes
?coefplot
library(coefplot)
coefplot(modelo.1) # plot de coeficientes
plotreg(modelo.1) # plot de coeficientes
detach("package:texreg", unload=TRUE)
plotreg(modelo.1) # plot de coeficientes
# Plotear modelo
# install.packages("coefplot")
library(coefplot)
plotreg(modelo.1) # plot de coeficientes
# Plotear modelo
# install.packages("coefplot")
library(coefplot)
coefplot(modelo.1) # plot de coeficientes
cat("\014")
rm(list=ls())
graphics.off()
library(foreign) # significa "foraneo"
dat <- read.dta("cow.dta") # cargar base en  R (hasta el momento solo la habiamos descargado).
# Hoy pensaremos en que factores ayudan a subir la poblacion en los paises.
# (1) Que relacion podria haber entre poblacion y democracia?
# (2) Que relacion podria haber entre poblacion y represion politica?
# Modelo
modelo.1 = lm(pop ~ democracy + repression, dat)
summary(modelo.1)
library(coefplot)
coefplot(modelo.1) # plot de coeficientes
# Veamos mas en detalle el problema...
# install.packages("effects")
library(effects)
plot(allEffects(modelo.1))
devtools::install_github("cardiomoon/webr")
install.packages(devtools)
install.packages("devtools")
# install.packages("devtools")
library(devtools)
install_github("cardiomoon/webr")
library(webr)
library(texreg)
screen(modelo.1)
screenreg(modelo.1)
screenreg(modelo.1, ci = T)
?screenreg
screenreg(modelo.1, ci.force = T)
screenreg(modelo.1, ci.force = c(T))
## Tabla convencional
screenreg(modelo.1, ci.force = F) # notan la diferencia?
summary(modelo.1)
pt(48303, nrow(dat)-2)
plot(pt(48303, nrow(dat)-2))
48303/19052
48303/19052
2345/6036
18707/15973
y = rnorm(1000, 0)
y
x1 = rnorm(1000, 10)
x2 = rnorm(1000, 20)
x3 = rnorm(1000, 30)
# El "VERDADERO MODELO": y es una combinacion lineal de todas las variables.
y = b0 + b1*x1 + b2*x2 + b3*x3 + e
# Inventemos las variables independientes
x1 = rnorm(1000, 10) # como nunca, conocemos que el promedio REAL de esta variable es 10
x2 = rnorm(1000, 20) # como nunca, conocemos que el promedio REAL de esta variable es 20
x3 = rnorm(1000, 30) # como nunca, conocemos que el promedio REAL de esta variable es 30
# Definamos que, como debiera ser, el error tiene promedio cero.
e = rnorm(1000, 0)
# Establecer el valor real de los betas
b0 = 0
b1 = 1
b2 = 2
b3 = 3
# El "VERDADERO MODELO": y es una combinacion lineal de todas las variables.
y = b0 + b1*x1 + b2*x2 + b3*x3 + e
summary(lm(y ~ x1 + x2 + x3))
b0 = 2
b1 = 1
b2 = 2
b3 = 3
# El "VERDADERO MODELO": y es una combinacion lineal de todas las variables.
y = b0 + b1*x1 + b2*x2 + b3*x3 + e
# Para comprobar, hagamos una regresion.
summary(lm(y ~ x1 + x2 + x3))
b1 = 1
b2 = 2
b3 = 3
# El "VERDADERO MODELO": y es una combinacion lineal de todas las variables.
y = b1*x1 + b2*x2 + b3*x3 + e
# Para comprobar, hagamos una regresion.
summary(lm(y ~ x1 + x2 + x3))
# Variable Omitida: Que pasa con nuestros coeficientes cuando se nos queda una
# variable afuera?
summary(lm(y ~ x1 + x2)) # sin sorpresa, los betas son los mismos que inventamos nosotros.
# Variable Omitida: Que pasa con nuestros coeficientes cuando se nos queda una
# variable afuera?
summary(lm(y ~ x1)) # sin sorpresa, los betas son los mismos que inventamos nosotros.
# Inventemos las variables independientes
x1 = rnorm(1000, 10) # como nunca, conocemos que el promedio REAL de esta variable es 10
x2 = rnorm(1000, 20) # como nunca, conocemos que el promedio REAL de esta variable es 20
x3 = rnorm(1000, 30) # como nunca, conocemos que el promedio REAL de esta variable es 30
# Definamos que, como debiera ser, el error tiene promedio cero.
e = rnorm(1000, 0)
# Establecer el valor real de los betas
b1 = 1
b2 = -100
b3 = 500
# El "VERDADERO MODELO": y es una combinacion lineal de todas las variables.
y = b1*x1 + b2*x2 + b3*x3 + e
# Hagamos una regresion.
summary(lm(y ~ x1 + x2 + x3)) # sin sorpresa, los betas son los mismos que inventamos nosotros.
# Variable Omitida: Que pasa con nuestros coeficientes cuando se nos queda una
# variable afuera?
summary(lm(y ~ x1)) # sin sorpresa, los betas son los mismos que inventamos nosotros.
# Variable Omitida: Que pasa con nuestros coeficientes cuando se nos queda una
# variable afuera?
summary(lm(y ~ x1 + x2)) # sin sorpresa, los betas son los mismos que inventamos nosotros.
y
summary(modelo.1)
cat("\014")
rm(list=ls())
graphics.off()
# Cargar paquete para cargar bases que no son de R.
# install.packages("foreign")
library(foreign) # significa "foraneo"
dat <- read.dta("cow.dta") # cargar base en  R (hasta el momento solo la habiamos descargado).
# Estimar modelo lineal: relacion entre crecimiento economico y democracia, controlando por poblacion
modelo.1 = lm(rgdpch ~ democracy + pop, dat)
# Primero, obtengamos el error
e = as.vector(modelo.1$residuals)
e # es simplemente un vector con todos los errores (diferencia entre observado
# y predicho?)
# Segundo, veamos cuantos parametros estimamos. Sera importante para la formula.
k = 3 # numero de variables a estimar (incluyendo intercepto).
# Tenemos "democracy", "pop", "Intercept". Entonces, tenemos 3 parametros.
# sigma.2 (varianza del error)
# Varianza es una medida de la variabilidad o dispersion de un vector.
# En este caso, del vector "e", que es nuestro error.
# Matematicamente, es la suma de los elementos diagonales que resultan de multiplicacion entre el vector del error
# y el vector del error traspuesto, dividido por la cantidad de observaciones,
# menos el numero de parametros que estaremos estimando (3 en este ejemplo).
sigma.2 = (1/(nrow(dat)-k))*sum(diag(e %*% t(e)))
unos = rep(1, nrow(dat)) # repetir "1" 112 veces, que es el largo de la base de datos
# que lo acabo de calcualr con "nrow(dat)".
## OK, ahora creemos la matrix "x".
x = matrix(c(unos, dat$democracy, dat$pop), ncol=3)
x # Ve como quedo.
# Cuarto, estimemos los errores estandard.
# Es importante sacar los errores estandard porque necesitamos eso
# para calcular los intervalos de confianza.
# Los errores estandard de hecho, salen en nuestra tabla de regresion.
summary(modelo.1) # "Std. Error"
library(matlib) # paquete para hacer operaciones con matrices.
# Calculemos la Matriz de Varianza-Covarianza
# Multiplicar sigma^2 por (x'x)^-1
sigma.2 * inv(t(x) %*% x)
# Clase 16: Intervalos de Confianza
#################################################################
cat("\014")
library(foreign) # significa "foraneo"
dat <- read.dta("cow.dta") # cargar base en  R (hasta el momento solo la habiamos descargado).
# Estimar modelo lineal: relacion entre crecimiento economico y democracia, controlando por poblacion
modelo.1 = lm(rgdpch ~ democracy + pop, dat)
summary(modelo.1)
# resumen del modelo
options(scipen = 1000000) # apagar notacion cientifica.
summary(modelo.1)
# Estimar modelo lineal: relacion entre crecimiento economico y democracia, controlando por poblacion
modelo.1 = lm(rgdpch ~ pop + democracy, dat)
# resumen del modelo
options(scipen = 1000000) # apagar notacion cientifica.
summary(modelo.1)
# Estimar modelo lineal: relacion entre crecimiento economico y democracia, controlando por poblacion
modelo.1 = lm(rgdpch ~ democracy + pop, dat)
# resumen del modelo
options(scipen = 1000000) # apagar notacion cientifica.
summary(modelo.1)
# Obtener intervalos de confianza
## Estos valores representan la incertidumbre de nuestra estimacion al promedio de cada variable,
## manteniendo las otras variables independientes "constantes en sus medias".
confint(modelo.1, level = 0.95) # 95% de confianza
confint(modelo.1, level = 0.99) # 99% de confianza
library(coefplot, ggplot2)
coefplot(modelo.1) # plot de coeficientes
# install.packages("effects")
library(effects)
plot(allEffects(modelo.1))
dat$log.pop = log(dat$pop)
# Estimar modelo lineal: relacion entre crecimiento economico y democracia, controlando por poblacion
modelo.1 = lm(rgdpch ~ democracy + log.pop, dat)
coefplot(modelo.1) # plot de coeficientes
plot(allEffects(modelo.1))
# Estimar modelo lineal: relacion entre crecimiento economico y democracia, controlando por poblacion
modelo.1 = lm(rgdpch ~ democracy + pop, dat)
modelo.1
modelo.1$residuals
# Primero, obtengamos el error
e = as.vector(modelo.1$residuals)
e # es simplemente un vector con todos los errores (diferencia entre observado
# Segundo, veamos cuantos parametros estimamos. Sera importante para la formula.
k = 3 # numero de variables a estimar (incluyendo intercepto).
# Segundo, veamos cuantos parametros estimamos. Sera importante para la formula.
k = 3 # numero de variables a estimar (incluyendo intercepto).
sum(diag(e %*% t(e)))
dat
nrow(dat)
# sigma.2 (varianza del error)
# Varianza es una medida de la variabilidad o dispersion de un vector.
# En este caso, del vector "e", que es nuestro error.
# Matematicamente, es la suma de los elementos diagonales que resultan de multiplicacion entre el vector del error
# y el vector del error traspuesto, dividido por la cantidad de observaciones,
# menos el numero de parametros que estaremos estimando (3 en este ejemplo).
sigma.2 = (1/(nrow(dat)-k))*sum(diag(e %*% t(e)))
sigma.2
# Tercero, obtengamos la matriz "x". La matriz "x" representa lo que observamos.
## Recuerda que para calcular el intercepto,
## debemos poner una columna de 1's del mismo largo que la dimension
## de el resto de las variables
unos = rep(1, nrow(dat)) # repetir "1" 112 veces, que es el largo de la base de datos
unos
dat$democracy
dat$pop
## OK, ahora creemos la matrix "x".
x = matrix(c(unos, dat$democracy, dat$pop), ncol=3)
x # Ve como quedo.
summary(modelo.1) # "Std. Error"
sigma.2
sigma.2 * inv(t(x) %*% x)
# Pero habia un camino mas corto...
vcov(modelo.1)
# Lo interesante es que la raiz cuadrada de la diagonal, son los
# errores estandard.
sqrt(diag(sigma.2 * inv(t(x) %*% x)))
# Pero habia un camino mas corto...
vcov(modelo.1)
diag(sigma.2 * inv(t(x) %*% x))
sqrt(diag(sigma.2 * inv(t(x) %*% x)))
10631.611789   / 754.563026
1638.874546   / 231.550113
-0.002947     / 0.004231
# Comprobemos. Los errores std. del "summary" debieran ser los mismos
# que los que estimamos nosotros manualmente.
summary(modelo.1)
# OK. Una manera de anotar esto, es extraer elemento
# por elemento de lo que acabamos de calcular.
sqrt(diag(sigma.2 * inv(t(x) %*% x)))[1] # error std. del intercepto
sqrt(diag(sigma.2 * inv(t(x) %*% x)))[2] # error std. de democracy
sqrt(diag(sigma.2 * inv(t(x) %*% x)))[3] # error std. de pop.
#### Ocupemos una funcion para conseguir estos valores criticos.
t = qt(1-.05/2, grados.de.libertad) # valores criticos de t, a un 95% de confianza.
### Antes de seguir, definamos los "grados de libertad"
### Se define como el numero de observaciones - 2.
grados.de.libertad = nrow(dat)-2
grados.de.libertad # ...veamos.
nrow(dat)
#### Ocupemos una funcion para conseguir estos valores criticos.
t = qt(1-.05/2, grados.de.libertad) # valores criticos de t, a un 95% de confianza.
t
sigma.2
sqrt(diag(sigma.2 * inv(t(x) %*% x)))
sqrt(diag(sigma.2 * inv(t(x) %*% x)))
10631.611789 + t * sqrt(diag(sigma.2 * inv(t(x) %*% x)))[1]  # (Intercept)
10631.611789 - t * sqrt(diag(sigma.2 * inv(t(x) %*% x)))[1]  # (Intercept)
confint(modelo.1, level = 0.95) # 95% de confianza
confint(modelo.1, level = 0.95) # 95% de confianza
#
10631.611789 + t * sqrt(diag(sigma.2 * inv(t(x) %*% x)))[1]  # (Intercept)  #  9136.09240230
10631.611789 - t * sqrt(diag(sigma.2 * inv(t(x) %*% x)))[1]  # (Intercept)  #  12127.13117506
#
1638.874546  + t * sqrt(diag(sigma.2 * inv(t(x) %*% x)))[2]  # democracy
1638.874546  - t * sqrt(diag(sigma.2 * inv(t(x) %*% x)))[2]  # democracy  #
?coefplot
coefplot(modelo.1, predictors="color", strict=TRUE)
coefplot(modelo.1, strict=TRUE)
