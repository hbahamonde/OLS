10^2
(3+3)/2
as.Date('1/15/2001',format='%m/%d/%Y')
as.Date('1/15/2001',format='%m/%d/%Y')
a>b
a = as.Date('1/15/2001',format='%m/%d/%Y')
b = as.Date('1/16/2001',format='%m/%d/%Y')
c = as.Date('1/17/2001',format='%m/%d/%Y')
a>b
plot(a,b,c)
ts.plot(a,b,c)
base.de.datos <- data.frame(
diabetico = c(TRUE, FALSE, TRUE, FALSE),
kilos = c(65, 69, 71, 73))
base.de.datos
base.de.datos[3,2] # fila 3, columna 2
base.de.datos[,"diabetico"] # todas las filas de la columna "diabetico"
## Nombres de las Columnas
colnames(base.de.datos)
## Cambiar el nombre de las columnas
colnames(base.de.datos) <- c("diabetico", "edad")
## Comprueba...
colnames(base.de.datos)
base.de.datos
## Resumen del df
summary(base.de.datos)
c(10, seq(5, 1, -1))
library(car) # carguemos la base, que viene en la lubreria "car"
library("car") # carguemos la base, que viene en la lubreria "car"
## Prestige
install.packages("car") # Esta es la libreria de graficos mas potentes que existe.
## Resumen de la base
summary(Prestige)
## Veamos como se ve toda la base
View(Prestige)
labels(Prestige)
## Veamos como se ve toda la base
View(Prestige)
### que columnas tiene el DF Prestige?
colnames(Prestige)
library(car) # ahora, carguemos la base, que viene en la libreria "car"
## Prestige
install.packages("car") # instalemos la base, que viene en la lubreria "car"
library(car) # ahora, carguemos la base, que viene en la libreria "car"
### que columnas tiene el DF Prestige?
colnames(Prestige)
### OK. DF1 tendra todo menos type, census, prestige
Prestige.drop.1 = select(Prestige,-c(type, census, prestige))
## Funcion Drop
install.packages("dplyr")
library(Dplyr)
library(dplyr)
### OK. DF1 tendra todo menos type, census, prestige
Prestige.drop.1 = select(Prestige,-c(type, census, prestige))
Prestige.drop.1
colnames(Prestige.drop.1)
### que columnas tiene el DF Prestige?
colnames(Prestige)
### OK. DF2 tendra todo menos type, census, prestige
Prestige.drop.2 = select(Prestige,-c(education, income))
colnames(Prestige.drop.2)
merge(Prestige.drop.1, Prestige.drop.2,by=c("woman"))
Prestige.drop.1
colnames(Prestige.drop.1)
colnames(Prestige.drop.2)
merge(Prestige.drop.1, Prestige.drop.2,by=c("women"))
## ---- earthquake:map:data:chile ----
## packages
if (!require("pacman")) install.packages("pacman"); library(pacman)
p_load(rgdal, foreign, rgeos, ggplot2)
# load shape file
chile.provinces <- readOGR(dsn = "/Users/hectorbahamonde/RU/Data/shape_files/division_provincial",
layer = "division_provincial",
verbose = FALSE)
#chile.provinces <- gSimplify(chile.provinces, tol=10000, topologyPreserve=T)
chile.provinces <- spTransform(chile.provinces, CRS("+proj=longlat +datum=WGS84"))
chile.provinces <- fortify(chile.provinces)
# chile.provinces <- chile.provinces[!(chile.provinces$long <= -76),]
# load eq data
load("/Users/hectorbahamonde/RU/Dissertation/Papers/Earthquake_Paper/eq_output_d_Chile.RData")
# rename df
dat.chile = dat
#dat.chile <- dat.chile[!(dat.chile$Longitude <= -76),]
dat.chile = dat.chile[!is.na(dat.chile$Magnitude),]
dat.chile = dat.chile[!is.na(dat.chile$Deaths),]
dat.chile = dat.chile[!is.na(dat.chile$Sector),]
dat.chile = dat.chile[!is.na(dat.chile$Population),]
dat.chile = dat.chile[!is.na(dat.chile$Latitude),]
dat.chile = dat.chile[!is.na(dat.chile$Longitude),]
dat.chile = dat.chile[!is.na(dat.chile$Urban),]
chile.map.plot.d <- data.frame(
Longitude = na.omit(dat.chile$Longitude),
Latitude = na.omit(dat.chile$Latitude),
Magnitude = na.omit(dat.chile$Magnitude),
Sector = na.omit(dat.chile$Sector),
Year = na.omit(dat.chile$year))
# chile.map.plot.d$Sector<- as.character(chile.map.plot.d$Sector)
# chile.map.plot.d$Sector[chile.map.plot.d$Sector==""] <- NA
# chile.map.plot.d$Sector <- as.factor(chile.map.plot.d$Sector)
# prepare DF for plot
chile.map.plot.d = data.frame(na.omit(chile.map.plot.d));rownames(chile.map.plot.d) <- NULL
# plot
earthquake.map.plot.chile = ggplot() +
geom_polygon(aes(x=long, y=lat, group=group), fill='grey', size=.05, color='black', data=chile.provinces, alpha=1/2) +
theme_bw() +
ggtitle(NULL) +
geom_point(data=chile.map.plot.d, aes(x=Longitude, y=Latitude,colour=Sector, shape=as.factor(round(chile.map.plot.d$Magnitude,0)))) +#shape=21,
scale_y_continuous(name='Latitude') +
scale_x_continuous(name='Longitude') +
scale_shape_discrete(name="Rounded\nMagnitude") +
theme(axis.text.y = element_text(size=7),
axis.text.x = element_text(size=7),
axis.title.y = element_text(size=7),
axis.title.x = element_text(size=7),
legend.text=element_text(size=12),
legend.title=element_text(size=12),
plot.title = element_text(size=7),
legend.position="bottom")
## ----
## packages
if (!require("pacman")) install.packages("pacman"); library(pacman)
p_load(rgdal, foreign, rgeos, ggplot2)
# load eq data
load("/Users/hectorbahamonde/RU/Dissertation/Papers/Earthquake_Paper/Peru_Data_Earthquake.RData")
# load shape file
peru.provinces <- readOGR(dsn = "/Users/hectorbahamonde/RU/Data/shape_files/peru_provinces/Limite_provincial", layer = "BAS_LIM_PROVINCIA")
#peru.provinces <- gSimplify(peru.provinces, tol=10000, topologyPreserve=T)
peru.provinces <- spTransform(peru.provinces, CRS("+proj=longlat +datum=WGS84"))
peru.provinces <- fortify(peru.provinces)
#peru.provinces <- peru.provinces[!(peru.provinces$long <= -76),]
peru.map = ggplot() +
geom_polygon(aes(x=long, y=lat, group=group), fill='grey', size=.05, color='black', data=peru.provinces, alpha=1/2) +
theme_bw() +
ggtitle("Peru") +
geom_point(data=subset(dat.peru, year>=1900), aes(x=Longitude, y=Latitude, size=Magnitude), color="red", shape=21)
# grid_arrange_shared_legend function
grid_arrange_shared_legend <- function(..., ncol = length(list(...)), nrow = 1, position = c("bottom", "right")) {
plots <- list(...)
position <- match.arg(position)
g <- ggplotGrob(plots[[1]] + theme(legend.position = position))$grobs
legend <- g[[which(sapply(g, function(x) x$name) == "guide-box")]]
lheight <- sum(legend$height)
lwidth <- sum(legend$width)
gl <- lapply(plots, function(x) x + theme(legend.position="none"))
gl <- c(gl, ncol = ncol, nrow = nrow)
combined <- switch(position,
"bottom" = arrangeGrob(do.call(arrangeGrob, gl),
legend,
ncol = 1,
heights = unit.c(unit(1, "npc") - lheight, lheight)),
"right" = arrangeGrob(do.call(arrangeGrob, gl),
legend,
ncol = 2,
widths = unit.c(unit(1, "npc") - lwidth, lwidth)))
grid.newpage()
grid.draw(combined)
}
### plot both countries
grid_arrange_shared_legend(chile.map, peru.map, ncol = 1, nrow = 2)
### plot both countries
p_load(grid)
grid.draw(cbind(ggplotGrob(chile.map), ggplotGrob(peru.map), size="last"))
# load shape file
peru.provinces <- readOGR(dsn = "/Users/hectorbahamonde/RU/Data/shape_files/peru_provinces/Limite_provincial", layer = "BAS_LIM_PROVINCIA")
#peru.provinces <- gSimplify(peru.provinces, tol=10000, topologyPreserve=T)
peru.provinces <- spTransform(peru.provinces, CRS("+proj=longlat +datum=WGS84"))
peru.provinces <- fortify(peru.provinces)
peru.map = ggplot() +
geom_polygon(aes(x=long, y=lat, group=group), fill='grey', size=.05, color='black', data=peru.provinces, alpha=1/2) +
theme_bw() +
ggtitle("Peru") +
geom_point(data=subset(dat.peru, year>=1900), aes(x=Longitude, y=Latitude, size=Magnitude), color="red", shape=21)
# grid_arrange_shared_legend function
grid_arrange_shared_legend <- function(..., ncol = length(list(...)), nrow = 1, position = c("bottom", "right")) {
plots <- list(...)
position <- match.arg(position)
g <- ggplotGrob(plots[[1]] + theme(legend.position = position))$grobs
legend <- g[[which(sapply(g, function(x) x$name) == "guide-box")]]
lheight <- sum(legend$height)
lwidth <- sum(legend$width)
gl <- lapply(plots, function(x) x + theme(legend.position="none"))
gl <- c(gl, ncol = ncol, nrow = nrow)
combined <- switch(position,
"bottom" = arrangeGrob(do.call(arrangeGrob, gl),
legend,
ncol = 1,
heights = unit.c(unit(1, "npc") - lheight, lheight)),
"right" = arrangeGrob(do.call(arrangeGrob, gl),
legend,
ncol = 2,
widths = unit.c(unit(1, "npc") - lwidth, lwidth)))
grid.newpage()
grid.draw(combined)
}
### plot both countries
grid_arrange_shared_legend(chile.map, peru.map, ncol = 1, nrow = 2)
chile.map
peru.map
earthquake.map.plot.chile
seq(10, 1, -2)
rm(list=ls())
cat("\014")
rm(list=ls())
cat("\014")
vector.n = c(1,2,3,4)
vector.n
is(vector.n)
cat("\014")
rm(list=ls())
rm(list=ls())
cat("\014")
cat("\014")
rm(list=ls())
cat("\014")
rm(list=ls())
cat("\014")
cat("\014")
rm(list=ls())
cat("\014")
rm(list=ls())
cat("\014")
rm(list=ls())
dos = "dos"
# 1+2
# 1+2
1+2
3+3
10/2
10^2
(3+3)/2
install.packages("ggplot2") # Esta es la libreria de graficos mas potentes que existe.
install.packages("ggplot2")
library("ggplot2", lib.loc="/Library/Frameworks/R.framework/Versions/3.6/Resources/library")
detach("package:ggplot2", unload=TRUE)
remove.packages("ggplot2")
install.packages("ggplot2") # Esta es la libreria de graficos mas potentes que existe.
install.packages("ggplot2")
library("ggplot2", lib.loc="/Library/Frameworks/R.framework/Versions/3.6/Resources/library")
library(ggplot2)
## Ahora voy a hacer un grafico
# install.packages("ggplot2") # Esta es la libreria de graficos mas potentes que existe.
library(ggplot2)
## Ahora voy a hacer un grafico
# install.packages("ggplot2") # Esta es la libreria de graficos mas potentes que existe.
library(ggplot2)
remove.packages("cowplot")
library(ggplot2)
help(seq)
seq(from = 1, to = 10)
# Supongamos que necesitabamos esta freq. cada dos numeros. Usemos el argumento "by"
seq(from = 1, to = 10, by=2)
# Y de mayor a menor?
seq(10, 1, -2)
seq(from = 10, to = 1, by = 2)
# Y de mayor a menor?
seq(10, 1, 2)
seq(from = 1, to = 10, by = 2)
seq(1, 10, 2)
seq(from = 1, to = 10, by = 2)
help(sequence)
help(secuencia)
??rep
rep("esta es la mejor clase del semestre", 100)
rep("esta es la mejor clase del semestre", 100)
# combinemos las funciones seq y rep. Usemos una estructura "anidada" (i.e. una funcion dentro de otra).
rep(seq(1, 4, 1), 5)
# combinemos las funciones seq y rep. Usemos una estructura "anidada" (i.e. una funcion dentro de otra).
rep(
seq(1, 4, 1), 5
)
# combinemos las funciones seq y rep. Usemos una estructura "anidada" (i.e. una funcion dentro de otra).
rep(
seq(1, 4, 1), 5
)
# combinemos las funciones seq y rep. Usemos una estructura "anidada" (i.e. una funcion dentro de otra).
rep(
seq(1, 4, 1), 5
)
1000.2
1,000
1000.2
# La ventaja de R es que esta orientado a "objetos". Creemos uno.
abc <- 3
# Aqui, acabamos de crear el objeto "abc", al que le hemos asignado un numero (el 3).
# Ahora "llamemos" el objeto "abc"
abc
## Fijate que en la consola aparece "[1] 3". Eso significa que solo hay una linea "[1]", que contiene el objeto 3.
## Ahora creemos un objeto, pero que en vez de contener un numero, contenga texto.
tres <- "cuatro"
## Llamemos al objeto "tres"
tres
## Fijate que el texto entra como texto cada vez que le ponemos comillas. Mira:
tres <- "3"
abc + abc
## Acabamos de sumar el objeto "abc". Ahora tratemos de elevar el objeto "abc" al cuadrado, y guardar ese resultado (9) en otro objeto.
abc.al.cuadrado <- abc^2
abc.al.cuadrado
ls()
## borra todo lo que creaste.
rm(list=ls())
## revisa nuevamente que tienes...
ls() # nada.
# Vector numerico
mi.primer.vector = c(1,2,3,4,10)
mi.primer.vector
# Vector de texto
vector.t = c("uno", "dos", "tres", "cuatro", "UOH")
vector.t
vector.n = c(1,2,3,4)
vector.n
vector.n.2 = vector.n*2
vector.n.2
vector.n.2
vector.n
# Comprobemos que vector.n.2 > vector.n
vector.n.2 > vector.n
vector.n.2
# acceder al segundo elemento de un vector
vector.n.2[4]
# acceder al segundo elemento de un vector
vector.n.2[4]
# acceder al segundo elemento de un vector
vector.n.2[40]
mi.informacion <- list(
clases=c("Contabilidad General", "Metodos", "Estadistica I"),
profes=c("X", "HB", "Y"),
WhatsApp=569475759
)
mi.informacion
mi.informacion[[2]]
# accedamos a un elemento por nombre
mi.informacion$clases
# accedamos a un elemento por nombre y posicion
mi.informacion$profe[2]
mi.informacion
mi.informacion$profe
mi.informacion$profe[2]
# creemos una lista, que es un objeto que permite una variedad de elementos dentro de ella.
mi.informacion <- list(
clases=c("Contabilidad General", "Metodos", "Estadistica I"),
profes=c("X", "HB", "Y"),
WhatsApp=+569475759
)
mi.informacion
# creemos una lista, que es un objeto que permite una variedad de elementos dentro de ella.
mi.informacion <- list(
clases=c("Contabilidad General", "Metodos", "Estadistica I"),
profes=c("X", "HB", "Y"),
WhatsApp="+569475759"
)
mi.informacion
seq(1,6)
1:6
1,56,89,1:3
# creemos una matriz, cuyos escalares (numeros) sigan una secuencia del 1 al 6, 1:6, y que tenga dos filas (rows).
a <- matrix(1:6, nrow=2)
a
a[2,3]
# all rows column 2
b[,2]
# all rows column 2
a[,2]
a[1,]
a = as.Date("1/15/2001",format='%m/%d/%Y')
b = as.Date('1/16/2001',format='%m/%d/%Y')
c = as.Date('1/17/2001',format='%m/%d/%Y')
c
texto = "2001-01-17"
# ahora R entiende que una cantidad sea mayor (mas reciente) que otra (mas antigua)
a>b
a
texto
c
texto
c==texto
c=texto
# ahora R entiende que una cantidad sea mayor (mas reciente) que otra (mas antigua)
a>text
a = as.Date('1/15/2001',format='%m/%d/%Y')
a
texto = 'abc'
texto
texto = "abc"
texto
c=texto # compara ambos textos (que son iguales).
c
1=1
1!=2
data.frame(
nom.var.1 = c(1,2,3),
nom.var.2 = c("uno", "dos", "tres")
)
base.de.datos <- data.frame(
diabetico = c(TRUE, FALSE, TRUE, FALSE),
kilos = c(65, 69, 71, 73)
)
base.de.datos <- data.frame(
diabetico = c(TRUE, FALSE, TRUE, FALSE),
kilos = c(65, 69, 71, 73),
nombre = c("Pedro", "Juan", 'Diego', "Maria")
)
View(base.de.datos) # Igual a un Excel
# describir lo basico de un df
head(base.de.datos)
base.de.datos[3,2] # fila 3, columna 2
1:4
base.de.datos[1:2, "kilos"] # filtrando, pero usando el nombre de la columna. Para las filas, la secuencia de los dos primeros elementos.
base.de.datos[1:2, 2] # filtrando, pero usando el nombre de la columna. Para las filas, la secuencia de los dos primeros elementos.
base.de.datos[1:2, "Kilos"] # filtrando, pero usando el nombre de la columna. Para las filas, la secuencia de los dos primeros elementos.
base.de.datos[ ,"diabetico"] # todas las filas de la columna "diabetico"
## Nombres de las Columnas
colnames(base.de.datos)
## Acabas de descubrir un error. No eran kilos, si no que "edad". Cambia el nombre de las columnas.
colnames(base.de.datos) <- c("diabetico", "edad", "nombre")
## Comprueba...
colnames(base.de.datos)
base.de.datos
## Resumen del df
summary(base.de.datos)
summary(base.de.datos)
colnames(base.de.datos)
## Resumen del df
summary(base.de.datos)
summary(base.de.datos)
is(base.de.datos$nombre)
library(car) # ahora, carguemos la base que viene en la libreria "car"
head(Prestige)
View(Prestige)
summary(Prestige)
max(Prestige$prestige)
Prestige[, Prestige$prestige==max(Prestige$prestige)]
Prestige[Prestige$prestige==max(Prestige$prestige), ]
Prestige$prestige
mean(Prestige$prestige)
help(ifelse)
Prestige$prestige.2 <- ifelse(Prestige$prestige > mean(Prestige$prestige), "alto","bajo")
View(base.de.datos)
View(Prestige)
is(Prestige$type) # que es?
Prestige$prestige.2
as.numeric(Prestige$prestige.2)
Prestige$type
plot(Prestige$type)
library(plyr)
Prestige$type.2 <- revalue(Prestige$type, c(
"bc"="Tecnico",
"prof"="Profesional",
"wc"="Oficinista")
)
plot(Prestige$type)
plot(Prestige$type.2)
colnames(Prestige)
### OK. DF1 tendra todo menos type, census, prestige
Prestige.drop.1 = select(Prestige,-c(type, census, prestige))
library(dplyr)
Prestige.drop.1 = select(Prestige,-c(type, census, prestige))
colnames(Prestige.drop.1)
### OK. DF2 tendra todo menos education e income
Prestige.drop.2 = select(Prestige,-c(education, income))
colnames(Prestige.drop.2)
### Problema: ahora queremos hacer un "merge" de las dos DF's. El unico elemento en comun, es la variable "women"
# "Merge" es util cuando queremos combinar dos datasets. Por ej., si estudiamos economia politica, y queremos ver el
# el efecto de la democracia en el PIB, probablemente tengamos que buscar una base de datos de ciencia politica (donde este la
# variable "democracia") y otra base de datos de economia (donde este la variable "PIB"). Ahi hariamos un merge por pais.
Prestige.merge <- merge(Prestige.drop.1, Prestige.drop.2, by = c("women"))
Prestige.merge
Head(Prestige.merge)
head(Prestige.merge)
